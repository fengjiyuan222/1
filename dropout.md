dropout

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/363fcd71ba838ea5852ddcc7ee54f99b.png)

**那么为什么可以防止过拟合呢？**

（1）取平均的作用： 先回到标准的模型即没有dropout，我们用相同的训练数据去训练5个不同的神经网络，一般会得到5个不同的结果，此时我们可以采用 “5个结果取均值”或者“多数取胜的投票策略”去决定最终结果。例如3个网络判断结果为数字9,那么很有可能真正的结果就是数字9，其它两个网络给出了错误结果。这种“综合起来取平均”的策略通常可以有效防止过拟合问题。因为不同的网络可能产生不同的过拟合，取平均则有可能让一些“相反的”拟合互相抵消。dropout掉不同的隐藏神经元就类似在训练不同的网络，随机删掉一半隐藏神经元导致网络结构已经不同，整个dropout过程就相当于对很多个不同的神经网络取平均。而不同的网络产生不同的过拟合，一些互为“反向”的拟合相互抵消就可以达到整体上减少过拟合。

（2）减少神经元之间复杂的共适应关系： 因为dropout程序导致两个神经元不一定每次都在一个dropout网络中出现。这样权值的更新不再依赖于有固定关系的隐含节点的共同作用，阻止了某些特征仅仅在其它特定特征下才有效果的情况 。迫使网络去学习更加鲁棒的特征 ，这些特征在其它的神经元的随机子集中也存在。换句话说假如我们的神经网络是在做出某种预测，它不应该对一些特定的线索片段太过敏感，即使丢失特定的线索，它也应该可以从众多其它线索中学习一些共同的特征。从这个角度看dropout就有点像L1，L2正则，减少权重使得网络对丢失特定神经元连接的鲁棒性提高。

（3）Dropout类似于性别在生物进化中的角色：物种为了生存往往会倾向于适应这种环境，环境突变则会导致物种难以做出及时反应，性别的出现可以繁衍出适应新环境的变种，有效的阻止过拟合，即避免环境改变时物种可能面临的灭绝。

(4) 增加稀疏性
但当数据量小的时候，可以通过稀疏性，来增加特征的区分度。

**dropout过程**

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/8ee0dda4516ab66d49f45e59dfb50e9c.png)

1）首先随机（临时）删掉网络中一半的隐藏神经元，输入输出神经元保持不变（上图中虚线为部分临时被删除的神经元）。
2） 然后把输入x通过修改后的网络前向传播，然后把得到的损失结果通过修改的网络反向传播。一小批训练样本执行完这个过程后，在没有被删除的神经元上按照随机梯度下降法更新对应的参数（w，b）。
3）然后继续重复这一过程：
----恢复被删掉的神经元（此时被删除的神经元保持原样，而没有被删除的神经元已经有所更新）
----从隐藏层神经元中随机选择一个一半大小的子集临时删除掉（备份被删除神经元的参数）。
----对一小批训练样本，先前向传播然后反向传播损失并根据随机梯度下降法更新参数（w，b） （没有被删除的那一部分参数得到更新，删除的神经元参数保持被删除前的结果）。
不断重复这一过程。

一般用在train不用在test。



**dropout在神经网络中的过程**

## ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/8a8779f6727e6080d842f24775b05ef3.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/78f8d7a5732be80b2b5cc5eff607db87.png)



上面公式中Bernoulli函数是为了生成概率r向量，也就是随机生成一个0、1的向量。
代码层面实现让某个神经元以概率p停止工作，其实就是让它的激活函数值以概率p变为0。比如我们某一层网络神经元的个数为1000个，其激活函数输出值为y1、y2、y3、…、y1000，我们dropout比率选择0.4，那么这一层神经元经过dropout后，1000个神经元中会有大约400个的值被置为0。

```python
import torch
import torch.nn as nn
import numpy as np

def dropout(X, drop_prob):
    X=X.float()
    assert 0 <= drop_prob  <= 1
    keep_prob = 1-drop_prob
    if keep_prob ==0:
        return torch.zeros_like(X)
    mask = (torch.randn(X.shape) < keep_prob).float()
    return mask * X / keep_prob
```